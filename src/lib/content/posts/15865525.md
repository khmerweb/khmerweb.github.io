---
id: '15865525'
title: 'Testing Asynchronous Code'
categories: 'Testing'
thumb: ''
date: '2025-09-17T18:52:41'
bookTitle: 'Testing Node.js Application'
bookThumb: ''
bookChapter: 'Unit Testing'
videos: ''
---
<p>It's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Vitest needs to know when the code it is testing has completed, before it can move on to another test. Vitest has several ways to handle this.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Promises</strong></span></p><p>&nbsp;</p><p>Return a promise from your test, and Vitest will wait for that promise to resolve. If the promise is rejected, the test will fail.</p><p>&nbsp;</p><p>For example, let's say that fetchData returns a promise that is supposed to resolve to the string 'peanut butter'. We could test it with:</p><pre><code class="js javascript js-code">test('the data is peanut butter', () =&gt; {
  return fetchData().then(data =&gt; {
    expect(data).toBe('peanut butter');
  });
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Async/Await</strong></span></p><p>&nbsp;</p><p>Alternatively, you can use async and await in your tests. To write an async test, use the async keyword in front of the function passed to test. For example, the same fetchData scenario can be tested with:</p><pre><code class="js javascript js-code">test('the data is peanut butter', async () =&gt; {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

test('the fetch fails with an error', async () =&gt; {
  expect.assertions(1);
  try {
    await fetchData();
  } catch (error) {
    expect(error).toMatch('error');
  }
});</code></pre><p>&nbsp;</p><p>You can combine async and await with .resolves or .rejects.</p><pre><code class="js javascript js-code">test('the data is peanut butter', async () =&gt; {
  await expect(fetchData()).resolves.toBe('peanut butter');
});

test('the fetch fails with an error', async () =&gt; {
  await expect(fetchData()).rejects.toMatch('error');
});</code></pre><p>&nbsp;</p><p>In these cases, async and await are effectively syntactic sugar for the same logic as the promises example uses.</p><p>&nbsp;</p><blockquote><p>caution</p><p style="margin-left:0px;">Be sure to return (or await) the promise - if you omit the return/await statement, your test will complete before the promise returned from fetchData resolves or rejects.</p></blockquote><p style="margin-left:0px;">&nbsp;</p><p style="margin-left:0px;">If you expect a promise to be rejected, use the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test.</p><pre><code class="js javascript js-code">test('the fetch fails with an error', () =&gt; {
  expect.assertions(1);
  return fetchData().catch(error =&gt; expect(error).toMatch('error'));
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Callbacks</strong></span></p><p>&nbsp;</p><p>If you don't use promises, you can use callbacks. For example, let's say that fetchData, instead of returning a promise, expects a callback, i.e. fetches some data and calls callback(null, data) when it is complete. You want to test that this returned data is the string 'peanut butter'.</p><p>&nbsp;</p><p>By default, Vitest tests complete once they reach the end of their execution. That means this test will not work as intended:</p><pre><code class="js javascript js-code">// Don't do this!
test('the data is peanut butter', () =&gt; {
  function callback(error, data) {
    if (error) {
      throw error;
    }
    expect(data).toBe('peanut butter');
  }

  fetchData(callback);
});</code></pre><p>&nbsp;</p><p>The problem is that the test will complete as soon as fetchData completes, before ever calling the callback.</p><p>&nbsp;</p><p>There is an alternate form of test that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called done. Vitest will wait until the done callback is called before finishing the test.</p><pre><code class="js javascript js-code">test('the data is peanut butter', done =&gt; {
  function callback(error, data) {
    if (error) {
      done(error);
      return;
    }
    try {
      expect(data).toBe('peanut butter');
      done();
    } catch (error) {
      done(error);
    }
  }

  fetchData(callback);
});</code></pre><p>&nbsp;</p><p>If done() is never called, the test will fail (with timeout error), which is what you want to happen.</p><p>&nbsp;</p><p>If the expect statement fails, it throws an error and done() is not called. If we want to see in the test log why it failed, we have to wrap expect in a try block and pass the error in the catch block to done. Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>.resolves / .rejects</strong></span></p><p>&nbsp;</p><p>You can also use the .resolves matcher in your expect statement, and Vitest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</p><pre><code class="js javascript js-code">test('the data is peanut butter', () =&gt; {
  return expect(fetchData()).resolves.toBe('peanut butter');
});</code></pre><p>&nbsp;</p><p>Be sure to return the assertionâ€”if you omit this return statement, your test will complete before the promise returned from fetchData is resolved and then() has a chance to execute the callback.</p><p>&nbsp;</p><p>If you expect a promise to be rejected, use the .rejects matcher. It works analogically to the .resolves matcher. If the promise is fulfilled, the test will automatically fail.</p><pre><code class="js javascript js-code">test('the fetch fails with an error', () =&gt; {
  return expect(fetchData()).rejects.toMatch('error');
});</code></pre><p>&nbsp;</p><p>None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.</p>