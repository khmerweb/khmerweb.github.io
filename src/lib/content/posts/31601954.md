---
id: '31601954'
title: 'Setup and Teardown'
categories: 'Testing'
thumb: ''
date: '2025-09-18T11:51:23'
bookTitle: 'Testing Node.js Application'
bookThumb: ''
bookChapter: 'Introduction'
videos: ''
---
<p>Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Vitest provides helper functions to handle this.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Repeating Setup</strong></span></p><p>&nbsp;</p><p>If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach hooks.</p><p>&nbsp;</p><p>For example, let's say that several tests interact with a database of cities. You have a method initializeCityDatabase() that must be called before each of these tests, and a method clearCityDatabase() that must be called after each of these tests. You can do this with:</p><pre><code class="js javascript js-code">beforeEach(() =&gt; {
  initializeCityDatabase();
});

afterEach(() =&gt; {
  clearCityDatabase();
});

test('city database has Vienna', () =&gt; {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () =&gt; {
  expect(isCity('San Juan')).toBeTruthy();
});</code></pre><p>&nbsp;</p><p>beforeEach and afterEach can handle asynchronous code in the same ways that tests can handle asynchronous code - they can either take a done parameter or return a promise. For example, if initializeCityDatabase() returned a promise that resolved when the database was initialized, we would want to return that promise:</p><pre><code class="js javascript js-code">beforeEach(() =&gt; {
  return initializeCityDatabase();
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>One-Time Setup</strong></span></p><p>&nbsp;</p><p>In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Vitest provides beforeAll and afterAll hooks to handle this situation.</p><p>&nbsp;</p><p>For example, if both initializeCityDatabase() and clearCityDatabase() returned promises, and the city database could be reused between tests, we could change our test code to:</p><pre><code class="js javascript js-code">beforeAll(() =&gt; {
  return initializeCityDatabase();
});

afterAll(() =&gt; {
  return clearCityDatabase();
});

test('city database has Vienna', () =&gt; {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () =&gt; {
  expect(isCity('San Juan')).toBeTruthy();
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Scoping</strong></span></p><p>&nbsp;</p><p>The top level before* and after* hooks apply to every test in a file. The hooks declared inside a describe block apply only to the tests within that describe block.</p><p>&nbsp;</p><p>For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:</p><pre><code class="js javascript js-code">// Applies to all tests in this file
beforeEach(() =&gt; {
  return initializeCityDatabase();
});

test('city database has Vienna', () =&gt; {
  expect(isCity('Vienna')).toBeTruthy();
});

test('city database has San Juan', () =&gt; {
  expect(isCity('San Juan')).toBeTruthy();
});

describe('matching cities to foods', () =&gt; {
  // Applies only to tests in this describe block
  beforeEach(() =&gt; {
    return initializeFoodDatabase();
  });

  test('Vienna &lt;3 veal', () =&gt; {
    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);
  });

  test('San Juan &lt;3 plantains', () =&gt; {
    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);
  });
});</code></pre><p>&nbsp;</p><p>Note that the top-level beforeEach is executed before the beforeEach inside the describe block. It may help to illustrate the order of execution of all hooks.</p><pre><code class="js javascript js-code">beforeAll(() =&gt; console.log('1 - beforeAll'));
afterAll(() =&gt; console.log('1 - afterAll'));
beforeEach(() =&gt; console.log('1 - beforeEach'));
afterEach(() =&gt; console.log('1 - afterEach'));

test('', () =&gt; console.log('1 - test'));

describe('Scoped / Nested block', () =&gt; {
  beforeAll(() =&gt; console.log('2 - beforeAll'));
  afterAll(() =&gt; console.log('2 - afterAll'));
  beforeEach(() =&gt; console.log('2 - beforeEach'));
  afterEach(() =&gt; console.log('2 - afterEach'));

  test('', () =&gt; console.log('2 - test'));
});

// 1 - beforeAll
// 1 - beforeEach
// 1 - test
// 1 - afterEach
// 2 - beforeAll
// 1 - beforeEach
// 2 - beforeEach
// 2 - test
// 2 - afterEach
// 1 - afterEach
// 2 - afterAll
// 1 - afterAll</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Order of Execution</strong></span></p><p>&nbsp;</p><p>Vitest executes all describe handlers in a test file before it executes any of the actual tests. This is another reason to do setup and teardown inside before* and after* handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Vitest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.</p><p>&nbsp;</p><p>Consider the following illustrative test file and output:</p><pre><code class="js javascript js-code">describe('describe outer', () =&gt; {
  console.log('describe outer-a');

  describe('describe inner 1', () =&gt; {
    console.log('describe inner 1');

    test('test 1', () =&gt; console.log('test 1'));
  });

  console.log('describe outer-b');

  test('test 2', () =&gt; console.log('test 2'));

  describe('describe inner 2', () =&gt; {
    console.log('describe inner 2');

    test('test 3', () =&gt; console.log('test 3'));
  });

  console.log('describe outer-c');
});

// describe outer-a
// describe inner 1
// describe outer-b
// describe inner 2
// describe outer-c
// test 1
// test 2
// test 3</code></pre><p>&nbsp;</p><p>Just like the describe and test blocks Vitest calls the before* and after* hooks in the order of declaration. Note that the after* hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:</p><pre><code class="js javascript js-code">beforeEach(() =&gt; console.log('connection setup'));
beforeEach(() =&gt; console.log('database setup'));

afterEach(() =&gt; console.log('database teardown'));
afterEach(() =&gt; console.log('connection teardown'));

test('test 1', () =&gt; console.log('test 1'));

describe('extra', () =&gt; {
  beforeEach(() =&gt; console.log('extra database setup'));
  afterEach(() =&gt; console.log('extra database teardown'));

  test('test 2', () =&gt; console.log('test 2'));
});

// connection setup
// database setup
// test 1
// database teardown
// connection teardown

// connection setup
// database setup
// extra database setup
// test 2
// extra database teardown
// database teardown
// connection teardown</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>General Advice</strong></span></p><p>&nbsp;</p><p>If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that test command to a test.only:</p><pre><code class="js javascript js-code">test.only('this will be the only test that runs', () =&gt; {
  expect(true).toBe(false);
});

test('this test will not run', () =&gt; {
  expect('A').toBe('A');
});</code></pre><p>&nbsp;</p><p>If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you're not sure whether some shared state is being modified, you can also try a beforeEach that logs data.</p>