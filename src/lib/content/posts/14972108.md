---
id: '14972108'
title: 'Interface'
categories: 'TypeScript'
thumb: ''
date: '2025-09-22T15:19:26'
bookTitle: 'TypeScript for ES6 Developer'
bookThumb: ''
bookChapter: 'Interfaces'
videos: ''
---
<p>From Microsoft team</p><p>&nbsp;</p><p><strong>Summary</strong>: in this tutorial, you’ll learn about TypeScript interfaces and how to use them to enforce type-checking.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Introduction to TypeScript interfaces</strong></span></p><p>&nbsp;</p><p>TypeScript interfaces define the contracts within your code. They also provide explicit names for type checking.</p><p>&nbsp;</p><p>Let’s start with a simple example:</p><pre><code class="typescript">function getFullName(person: {
    firstName: string;
    lastName: string
}) {
    return `${person.firstName} ${person.lastName}`;
}

let person = {
    firstName: 'John',
    lastName: 'Doe'
};

console.log(getFullName(person));
</code></pre><p>&nbsp;</p><p>Output:</p><pre><code>John Doe</code></pre><p>&nbsp;</p><p>In this example, the TypeScript compiler checks the argument you pass into the getFullName() function.</p><p>&nbsp;</p><p>If the argument has two properties firstName and lastName and their types are strings, then the TypeScript compiler passes the check. Otherwise, it’ll issue an error.</p><p>&nbsp;</p><p>The type annotation of the function argument makes the code difficult to read. To address this issue, TypeScript introduces the concept of interfaces.</p><p>&nbsp;</p><p>The following uses an interface Person that has two string properties:</p><pre><code class="typescript">interface Person {
    firstName: string;
    lastName: string;
}</code></pre><p>&nbsp;</p><p>By convention, the interface names are in the PascalCase. They use a single capitalized letter to separate words in their names. For example, Person, UserProfile, and FullName.</p><p>&nbsp;</p><p>After defining the Person interface, you can use it as a type. For example, you can annotate the function parameter with the interface name:</p><pre><code class="typescript">function getFullName(person: Person) {
    return `${person.firstName} ${person.lastName}`;
}

let john = {
    firstName: 'John',
    lastName: 'Doe'
};

console.log(getFullName(john));</code></pre><p>&nbsp;</p><p>The code now is easier to read than before.</p><p>&nbsp;</p><p>To make the code more concise, you can use the object destructuring feature of JavaScript:</p><pre><code class="typescript">function getFullName({ firstName, lastName }: Person) {
  return `${firstName} ${lastName}`;
}</code></pre><p>&nbsp;</p><p>In the argument, we destructure the properties of the person object:</p><pre><code class="typescript">{ firstName, lastName }: Person</code></pre><p>&nbsp;</p><p>The getFullName() function will accept any object that has at least two string properties with the name firstName and lastName.</p><p>&nbsp;</p><p>For example, the following code declares an object that has four properties:</p><pre><code class="typescript">let jane = {
  firstName: 'Jane',
  middleName: 'K.',
  lastName: 'Doe',
  age: 22,
};</code></pre><p>&nbsp;</p><p>Since the jane object has two string properties firstName and lastName, you can pass it on to the getFullName() function as follows:</p><pre><code class="typescript">let fullName = getFullName(jane);
console.log(fullName); // Jane Doe</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Optional properties</strong></span></p><p>&nbsp;</p><p>An interface may have optional properties. To declare an optional property, you use the question mark (?) at the end of the property name in the declaration, like this:</p><pre><code class="typescript">interface Person {
    firstName: string;
    middleName?: string;
    lastName: string;
}</code></pre><p>&nbsp;</p><p>In this example, the Person interface has two required properties and one optional property.</p><p>&nbsp;</p><p>And the following shows how to use the Person interface in the getFullName() function:</p><pre><code class="typescript">function getFullName(person: Person) {
    if (person.middleName) {
        return `${person.firstName} ${person.middleName} ${person.lastName}`;
    }
    return `${person.firstName} ${person.lastName}`;
}
</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Readonly properties</strong></span></p><p>&nbsp;</p><p>If properties should be modifiable only when the object is first created, you can use the readonly keyword before the name of the property:</p><pre><code class="typescript">interface Person {
  readonly ssn: string;
  firstName: string;
  lastName: string;
}

let person: Person;
person = {
  ssn: '171-28-0926',
  firstName: 'John',
  lastName: 'Doe',
};
</code></pre><p>&nbsp;</p><p>In this example, the ssn property cannot be changed:</p><pre><code class="typescript">person.ssn = '171-28-0000';</code></pre><p>&nbsp;</p><p>Error:</p><pre><code>error TS2540: Cannot assign to 'ssn' because it is a read-only property.</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Function types</strong></span></p><p>&nbsp;</p><p>In addition to describing an object with properties, interfaces allow you to represent function types.</p><p>&nbsp;</p><p>To describe a function type, you assign the interface to the function signature that contains the parameter list with types and returned types. For example:</p><pre><code class="typescript">interface StringFormat {
    (str: string, isUpper: boolean): string
}</code></pre><p>&nbsp;</p><p>Now, you can use this function-type interface.</p><p>&nbsp;</p><p>The following illustrates how to declare a variable of a function type and assign it a function value of the same type:</p><pre><code class="typescript">let format: StringFormat;

format = function (str: string, isUpper: boolean) {
    return isUpper ? str.toLocaleUpperCase() : str.toLocaleLowerCase();
};

console.log(format('hi', true));</code></pre><p>&nbsp;</p><p>Output:</p><pre><code>HI</code></pre><p>&nbsp;</p><p>Note that the parameter names don’t need to match the function signature. The following example is equivalent to the above example:</p><pre><code class="typescript">let format: StringFormat;

format = function (src: string, upper: boolean) {
    return upper ? src.toLocaleUpperCase() : src.toLocaleLowerCase();
};

console.log(format('hi', true));</code></pre><p>&nbsp;</p><p>The StringFormat interface ensures that all the callers of the function that implements it pass in the required arguments: a string and a boolean.</p><p>&nbsp;</p><p>The following code also works perfectly fine even though the lowerCase is assigned to a function that doesn’t have the second argument:</p><pre><code class="typescript">let lowerCase: StringFormat;
lowerCase = function (str: string) {
    return str.toLowerCase();
}

console.log(lowerCase('Hi', false));</code></pre><p>&nbsp;</p><p>Notice that the second argument is passed when the lowerCase() function is called.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Class Types</strong></span></p><p>&nbsp;</p><p>If you have worked with Java or C#, you can find that the main use of the interface is to define a contract between classes.</p><p>&nbsp;</p><p>For example, the following Json interface can be implemented by any class:</p><pre><code class="typescript">interface Json {
  toJson(): string;
}</code></pre><p>&nbsp;</p><p>The following declares a class that implements the Json interface:</p><pre><code class="typescript">class Person implements Json {
  constructor(private firstName: string, private lastName: string) {}
  toJson(): string {
    return JSON.stringify(this);
  }
}</code></pre><p>&nbsp;</p><p>In the Person class, we implemented the toJson() method of the Json interface.</p><p>&nbsp;</p><p>The following example shows how to use the Person class:</p><pre><code class="typescript">let person = new Person('John', 'Doe');
console.log(person.toJson());</code></pre><p>&nbsp;</p><p>Output:</p><pre><code>{"firstName":"John","lastName":"Doe"}</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Summary</strong></span></p><p>&nbsp;</p><ul><li>TypeScript interfaces define contracts in your code and provide explicit names for type-checking.</li><li>Interfaces may have optional properties or read-only properties.</li><li>Interfaces can be used as function types.</li><li>Interfaces are typically used as class types that make a contract between unrelated classes.</li></ul>