---
id: '74053443'
title: 'TypeScript Generics'
categories: 'TypeScript'
thumb: ''
date: '2025-09-23T09:45:11'
bookTitle: 'TypeScript for ES6 Developer'
bookThumb: ''
bookChapter: 'Generics'
videos: ''
---
<p>From Microsoft team</p><p>&nbsp;</p><p><strong>Summary</strong>: in this tutorial, you’ll learn about TypeScript generics that allow you to use types as formal parameters.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Introduction to TypeScript Generics</strong></span></p><p>&nbsp;</p><p>TypeScript generics allow you to write reusable and generalized forms of functions, classes, and interfaces. In this tutorial, you’re focusing on developing generic functions.</p><p>&nbsp;</p><p>It’ll be easier to explain TypeScript generics through a simple example.</p><p>&nbsp;</p><p>Suppose you need to develop a function that returns a random number in an array of numbers.</p><p>&nbsp;</p><p>The following getRandomNumberElement() function takes an array of numbers as its parameter and returns a random element from the array:</p><pre><code class="typescript">function getRandomNumberElement(items: number[]): number {
    let randomIndex = Math.floor(Math.random() * items.length);
    return items[randomIndex];
}</code></pre><p>&nbsp;</p><p>To get a random element of an array, you need to:</p><p>&nbsp;</p><ul><li>Find the random index first.</li><li>Get the random element based on the random index.</li></ul><p>&nbsp;</p><p>To find the random index of an array, we use the Math.random() that returns a random number between 0 and 1, multiplies by the length of the array, and applies the Math.floor() on the result.</p><p>&nbsp;</p><p>The following shows how to use the getRandomNumberElement() function:</p><pre><code class="typescript">let numbers = [1, 5, 7, 4, 2, 9];
console.log(getRandomNumberElement(numbers));</code></pre><p>&nbsp;</p><p>Assuming that you need to get a random element from an array of strings. This time, you may come up with a new function:</p><pre><code class="typescript">function getRandomStringElement(items: string[]): string {
    let randomIndex = Math.floor(Math.random() * items.length);
    return items[randomIndex];
}</code></pre><p>&nbsp;</p><p>The logic of the getRandomStringElement() function is the same as in the getRandomNumberElement() function.</p><p>&nbsp;</p><p>This example shows how to use the getRandomStringElement() function:</p><pre><code class="typescript">let colors = ['red', 'green', 'blue'];
console.log(getRandomStringElement(colors));</code></pre><p>&nbsp;</p><p>Later you may need to get a random element in an array of objects. Creating a new function every time you want to get a random element from a new array type is not scalable.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Using any type</strong></span></p><p>&nbsp;</p><p>One option to address this issue is to set the type of the array argument as any[]. By doing this, you need to write one function that works with an array of any type.</p><pre><code class="typescript">function getRandomAnyElement(items: any[]): any {
    let randomIndex = Math.floor(Math.random() * items.length);
    return items[randomIndex];
}</code></pre><p>&nbsp;</p><p>The getRandomAnyElement() works with an array of the any type including number, string, object, and so on:</p><pre><code class="typescript">let numbers = [1, 5, 7, 4, 2, 9];
let colors = ['red', 'green', 'blue'];

console.log(getRandomAnyElement(numbers));
console.log(getRandomAnyElement(colors));</code></pre><p>&nbsp;</p><p>This option works fine but has a drawback: it doesn’t allow you to enforce the type of the returned element. In other words, it isn’t type-safe.</p><p>&nbsp;</p><p>A better solution to avoid code duplication while preserving the type is to use generics.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>TypeScript generics come to the rescue</strong></span></p><p>&nbsp;</p><p>The following shows a generic function that returns the random element from an array of type T:</p><pre><code class="typescript">function getRandomElement&lt;T&gt;(items: T[]): T {
    let randomIndex = Math.floor(Math.random() * items.length);
    return items[randomIndex];
}</code></pre><p>&nbsp;</p><p>This function uses type variable T. The T allows you to capture the type provided when calling the function. Additionally, the function uses the T type variable as its return type.</p><p>&nbsp;</p><p>This getRandomElement() function is generic because it can work with any data type including string, number, object,…</p><p>&nbsp;</p><p>By convention, we use the letter T as the type variable. However, you can freely use other letters such as A, B C, …</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Calling a generic function</strong></span></p><p>&nbsp;</p><p>The following shows how to use the getRandomElement() with an array of numbers:</p><pre><code class="typescript">let numbers = [1, 5, 7, 4, 2, 9];
let randomEle = getRandomElement&lt;number&gt;(numbers); 
console.log(randomEle);</code></pre><p>&nbsp;</p><p>This example explicitly passes number as the T type into the getRandomElement() function.</p><p>&nbsp;</p><p>In practice, you’ll use type inference for the argument. It means that you let the TypeScript compiler set the value of T automatically based on the type of argument that you pass into, like this:</p><pre><code class="typescript">let numbers = [1, 5, 7, 4, 2, 9];
let randomEle = getRandomElement(numbers); 
console.log(randomEle);</code></pre><p>&nbsp;</p><p>In this example, we didn’t pass the number type to the getRandomElement() explicitly. The compiler looks at the argument and sets T to its type.</p><p>&nbsp;</p><p>Now, the getRandomElement() function is also type-safe. For example, if you assign the returned value to a string variable, you’ll get an error:</p><pre><code class="typescript">let numbers = [1, 5, 7, 4, 2, 9];
let returnElem: string;
returnElem = getRandomElement(numbers);  // compiler error</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Generic functions with multiple types</strong></span></p><p>&nbsp;</p><p>The following illustrates how to develop a generic function with two type variables U and V:</p><pre><code class="typescript">function merge&lt;U, V&gt;(obj1: U, obj2: V) {
    return {
        ...obj1,
        ...obj2
    };
}</code></pre><p>&nbsp;</p><p>The merge() function merges two objects with the type U and V. It combines the properties of the two objects into a single object.</p><p>&nbsp;</p><p>Type inference infers the returned value of the merge() function as an intersection type of U and V, which is U &amp; V</p><p>&nbsp;</p><p>The following illustrates how to use the merge() function that merges two objects:</p><pre><code class="typescript">let result = merge(
    { name: 'John' },
    { jobTitle: 'Frontend Developer' }
);

console.log(result);</code></pre><p>&nbsp;</p><p>Output:</p><pre><code>{ name: 'John', jobTitle: 'Frontend Developer' }</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Benefits of TypeScript generics</strong></span></p><p>&nbsp;</p><p>The following are the benefits of TypeScript generics:</p><p>&nbsp;</p><ul><li>Leverage type checks at the compile time.</li><li>Eliminate type castings.</li><li>Allow you to implement generic algorithms.</li></ul><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Summary</strong></span></p><p>&nbsp;</p><ul><li>Use TypeScript generics to develop reusable, generalized, and type-safe functions, interfaces, and classes.</li></ul>