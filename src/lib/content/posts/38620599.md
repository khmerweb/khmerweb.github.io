---
id: '38620599'
title: 'Generic Constraints'
categories: 'TypeScript'
thumb: ''
date: '2025-09-23T10:12:18'
bookTitle: 'TypeScript for ES6 Developer'
bookThumb: ''
bookChapter: 'Generics'
videos: ''
---
<p>From Microsoft team</p><p>&nbsp;</p><p><strong>Summary</strong>: in this tutorial, you’ll learn about the generic constraints in TypeScript.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Introduction to generic constraints in TypeScript</strong></span></p><p>&nbsp;</p><p>Consider the following example:</p><pre><code class="typescript">function merge&lt;U, V&gt;(obj1: U, obj2: V) {
    return {
        ...obj1,
        ...obj2
    };
}</code></pre><p>&nbsp;</p><p>The merge() is a generic function that merges two objects. For example:</p><pre><code class="typescript">let person = merge(
    { name: 'John' },
    { age: 25 }
);

console.log(result);</code></pre><p>&nbsp;</p><p>Output:</p><pre><code>{ name: 'John', age: 25 }</code></pre><p>&nbsp;</p><p>It works perfectly fine.</p><p>&nbsp;</p><p>The merge() function expects two objects. However, it doesn’t prevent you from passing a non-object like this:</p><pre><code class="typescript">let person = merge(
    { name: 'John' },
    25
);

console.log(person);</code></pre><p>&nbsp;</p><p>Output:</p><pre><code class="typescript">{ name: 'John' }</code></pre><p>&nbsp;</p><p>TypeScript doesn’t issue any errors.</p><p>&nbsp;</p><p>Instead of working with all types, you may want to add a constraint to the merge() function so that it works with objects only.</p><p>&nbsp;</p><p>To do this, you need to list out the requirement as a constraint on what U and V types can be.</p><p>&nbsp;</p><p>In order to denote the constraint, you use the extends keyword. For example:</p><pre><code class="typescript">function merge&lt;U extends object, V extends object&gt;(obj1: U, obj2: V) {
    return {
        ...obj1,
        ...obj2
    };
}</code></pre><p>&nbsp;</p><p>Because the merge() function is now constrained, it will no longer work with all types. Instead, it works with the object type only.</p><p>&nbsp;</p><p>The following will result in an error:</p><pre><code class="typescript">let person = merge(
    { name: 'John' },
    25
);</code></pre><p>&nbsp;</p><p>Error:</p><pre><code>Argument of type '25' is not assignable to parameter of type 'object'.</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Using type parameters in generic constraints</strong></span></p><p>&nbsp;</p><p>TypeScript allows you to declare a type parameter constrained by another type parameter.</p><p>&nbsp;</p><p>The following prop() function accepts an object and a property name. It returns the value of the property.</p><pre><code class="typescript">function prop&lt;T, K&gt;(obj: T, key: K) {
    return obj[key];
}</code></pre><p>&nbsp;</p><p>The compiler issues the following error:</p><pre><code>Type 'K' cannot be used to index type 'T'.</code></pre><p>&nbsp;</p><p>To fix this error, you add a constraint to K to ensure that it is a key of T as follows:</p><pre><code class="typescript">function prop&lt;T, K extends keyof T&gt;(obj: T, key: K) {
    return obj[key];
}</code></pre><p>&nbsp;</p><p>If you pass into the prop function a property name that exists on the obj, the compiler won’t complain. For example:</p><pre><code class="typescript">let str = prop({ name: 'John' }, 'name');
console.log(str);</code></pre><p>&nbsp;</p><p>Output:</p><pre><code>John</code></pre><p>&nbsp;</p><p>However, if you pass a key that doesn’t exist on the first argument, the compiler will issue an error:</p><pre><code class="typescript">let str = prop({ name: 'John' }, 'age');</code></pre><p>&nbsp;</p><p>Error:</p><pre><code>Argument of type '"age"' is not assignable to parameter of type '"name"'.</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Summary</strong></span></p><p>&nbsp;</p><ul><li>Use extends keyword to constrain the type parameter to a specific type.</li><li>Use extends keyof to constrain a type that is the property of another object.</li></ul>