---
id: '98479854'
title: 'Using Matchers'
categories: 'Testing'
thumb: ''
date: '2025-09-17T15:32:18'
bookTitle: 'Testing Node.js Application'
bookThumb: ''
bookChapter: 'Unit Testing'
videos: ''
---
<p>Vitest uses "matchers" to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the expect API doc.</p><p>&nbsp;</p><p>Common Matchers</p><p>&nbsp;</p><p>The simplest way to test a value is with exact equality.</p><pre><code class="js javascript js-code">// sum.test.js
import { expect, test } from 'vitest'
import { sum } from './sum.js'

test('adds 1 + 2 to equal 3', () =&gt; {
  expect(sum(1, 2)).toBe(3)
})</code></pre><p>&nbsp;</p><p>In this code, expect(1 + 2) returns an "expectation" object. You typically won't do much with these expectation objects except call matchers on them. In this code, .toBe(3) is the matcher. When Vitest runs, it tracks all the failing matchers so that it can print out nice error messages for you.</p><p>&nbsp;</p><p>toBe uses Object.is to test exact equality. If you want to check the value of an object, use toEqual:</p><pre><code class="js javascript js-code">test('object assignment', () =&gt; {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});</code></pre><p>&nbsp;</p><p>You can also test for the opposite of a matcher using not:</p><pre><code class="js javascript js-code">test('adding positive numbers is not zero', () =&gt; {
  for (let a = 1; a &lt; 10; a++) {
    for (let b = 1; b &lt; 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Truthiness</strong></span></p><p>&nbsp;</p><p>In tests, you sometimes need to distinguish between undefined, null, and false, but you sometimes do not want to treat these differently. Vitest contains helpers that let you be explicit about what you want.</p><p>&nbsp;</p><ul><li>toBeNull matches only null</li><li>toBeUndefined matches only undefined</li><li>toBeDefined is the opposite of toBeUndefined</li><li>toBeTruthy matches anything that an if statement treats as true</li><li>toBeFalsy matches anything that an if statement treats as false</li></ul><p>&nbsp;</p><p>For example:</p><pre><code class="js javascript js-code">test('null', () =&gt; {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () =&gt; {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});</code></pre><p>&nbsp;</p><p>You should use the matcher that most precisely corresponds to what you want your code to be doing.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Numbers</strong></span></p><p>&nbsp;</p><p>Most ways of comparing numbers have matcher equivalents.</p><pre><code class="js javascript js-code">test('two plus two', () =&gt; {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});</code></pre><p>&nbsp;</p><p>For floating point equality, use toBeCloseTo instead of toEqual, because you don't want a test to depend on a tiny rounding error.</p><pre><code class="js javascript js-code">test('adding floating point numbers', () =&gt; {
  const value = 0.1 + 0.2;
  //expect(value).toBe(0.3);           This won't work because of rounding error
  expect(value).toBeCloseTo(0.3); // This works.
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Strings</strong></span></p><p>&nbsp;</p><p>You can check strings against regular expressions with toMatch:</p><pre><code class="js javascript js-code">test('there is no I in team', () =&gt; {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () =&gt; {
  expect('Christoph').toMatch(/stop/);
});</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Arrays and iterables</strong></span></p><p>&nbsp;</p><p>You can check if an array or iterable contains a particular item using toContain:</p><pre><code class="js javascript js-code">const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'milk',
];

test('the shopping list has milk on it', () =&gt; {
  expect(shoppingList).toContain('milk');
  expect(new Set(shoppingList)).toContain('milk');
});</code></pre><p>&nbsp;</p><p>If you want to test whether a particular function throws an error when it's called, use toThrowError.</p><pre><code class="js javascript js-code">function compileAndroidCode() {
  throw new Error('you are using the wrong JDK!');
}

test('compiling android goes as expected', () =&gt; {
  expect(() =&gt; compileAndroidCode()).toThrow();
  expect(() =&gt; compileAndroidCode()).toThrow(Error);

  // You can also use a string that must be contained in the error message or a regexp
  expect(() =&gt; compileAndroidCode()).toThrow('you are using the wrong JDK');
  expect(() =&gt; compileAndroidCode()).toThrow(/JDK/);

  // Or you can match an exact error message using a regexp like below
  expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails
  expect(() =&gt; compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass
});</code></pre><p>&nbsp;</p><p>This is just a taste. For a complete list of matchers, check out the reference docs.</p>