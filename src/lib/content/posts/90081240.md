---
id: '90081240'
title: 'Why Vitest'
categories: 'Testing, Node.js'
thumb: ''
date: '2025-09-17T11:22:32'
bookTitle: 'Testing Node.js Application'
bookThumb: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjxyy6nFcN2R8XOoFPKuTqL7re-uIX_k_wqz8rUwjPZCW9YmtteQD6dF7hDHeaoYXh0v2W_aKUERZlOmmodV1bINQlFdrUB9XCCrSgUoA7i680tedG_KBfXxKKaBRPcnYlrstvfEL5sVyhX6dmnaYaEPF1xnzVtabC_-3Ytu5PvHSTyYYCjzRRZBLF0Tu4/s1600/Capture.PNG'
bookChapter: 'Introduction'
videos: ''
---
<p>From Vitest team</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>The Need for a Vite Native Test Runner</strong></span></p><p>&nbsp;</p><p>Vite's out-of-the-box support for common web patterns, features like glob imports and SSR primitives, and its many plugins and integrations are fostering a vibrant ecosystem. Its dev and build story are key to its success. For docs, there are several SSG-based alternatives powered by Vite. Vite's Unit Testing story hasn't been clear though. Existing options like Jest were created in a different context. There is a lot of duplication between Jest and Vite, forcing users to configure two different pipelines.</p><p>&nbsp;</p><p>Using Vite dev server to transform your files during testing, enables the creation of a simple runner that doesn't need to deal with the complexity of transforming source files and can solely focus on providing the best DX during testing. A test runner that uses the same configuration of your App (through vite.config.js), sharing a common transformation pipeline during dev, build, and test time. That is extensible with the same plugin API that lets you and the maintainers of your tools provide first-class integration with Vite. A tool that is built with Vite in mind from the start, taking advantage of its improvements in DX, like its instant Hot Module Reload (HMR). This is Vitest, a next generation testing framework powered by Vite.</p><p>&nbsp;</p><p>Given Jest's massive adoption, Vitest provides a compatible API that allows you to use it as a drop-in replacement in most projects. It also includes the most common features required when setting up your unit tests (mocking, snapshots, coverage). Vitest cares a lot about performance and uses Worker threads to run as much as possible in parallel. Some ports have seen test running an order of magnitude faster. Watch mode is enabled by default, aligning itself with the way Vite pushes for a dev first experience. Even with all these improvements in DX, Vitest stays lightweight by carefully choosing its dependencies (or directly inlining needed pieces).</p><p>&nbsp;</p><p><strong>Vitest aims to position itself as the Test Runner of choice for Vite projects, and as a solid alternative even for projects not using Vite.</strong></p>