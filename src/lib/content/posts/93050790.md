---
id: '93050790'
title: 'Everyday Types'
categories: 'TypeScript'
thumb: ''
date: '2025-09-14T22:40:04'
bookTitle: 'TypeScript for ES6 Developer'
bookThumb: ''
bookChapter: 'Handbook'
videos: ''
---
<p><span style="font-size:21px;"><strong>The primitives: string, number, and boolean</strong></span></p><p>&nbsp;</p><p>JavaScript has three very commonly used primitives: string, number, and boolean. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript typeof operator on a value of those types:</p><p>&nbsp;</p><ul><li>string represents string values like "Hello, world"</li><li>number is for numbers like 42. JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply number</li><li>boolean is for the two values true and false</li></ul><p>&nbsp;</p><p>The type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Arrays</strong></span></p><p>&nbsp;</p><p>To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g. string[] is an array of strings, and so on). You may also see this written as Array&lt;number&gt;, which means the same thing. We’ll learn more about the syntax T&lt;U&gt; when we cover generics.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>any</strong></span></p><p>&nbsp;</p><p>TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.</p><p>&nbsp;</p><p>When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:</p><pre><code class="js javascript js-code">let obj: any = { x: 0 };
// None of the following lines of code will throw compiler errors.
// Using `any` disables all further type checking, and it is assumed
// you know the environment better than TypeScript.
obj.foo();
obj();
obj.bar = 100;
obj = "hello";
const n: number = obj;</code></pre><p>&nbsp;</p><p>The any type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>noImplicitAny</strong></span></p><p>&nbsp;</p><p>When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any.</p><p>&nbsp;</p><p>You usually want to avoid this, though, because any isn’t type-checked. Use the compiler flag noImplicitAny to flag any implicit any as an error.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Type Annotations on Variables</strong></span></p><p>&nbsp;</p><p>When you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:</p><pre><code class="js javascript js-code">let myName: string = "Alice";</code></pre><p>&nbsp;</p><p>In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code. For example, the type of a variable is inferred based on the type of its initializer:</p><pre><code class="js javascript js-code">// No type annotation needed -- 'myName' inferred as type 'string'
let myName = "Alice";</code></pre><p>&nbsp;</p><p>For the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.</p><p>&nbsp;</p>