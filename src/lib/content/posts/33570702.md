---
id: '33570702'
title: 'The Basics'
categories: 'TypeScript'
thumb: ''
date: '2025-09-14T21:30:03'
bookTitle: 'TypeScript for ES6 Developer'
bookThumb: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiwm09XXyUUH0grpN8FviLTV5z1YbqosDDexjZ6ma4_s_WkNJV3vbO4XREjPTHJ3r5dERLc2JjAK-M0KsQd2JvvaudoqLTHJCOkc4M3p7sE30ZdiWvXoPZTX_dT_hpBZxTDH6Gz8BT4ZJJb_8XtHx8XF6WdAMM28XNgA9h6d3R_U6g9StM72MVfaF8J/s1600/typescript.png'
bookChapter: 'Handbook'
videos: ''
---
<p>From Microsoft team</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Static type-checking</strong></span></p><p>&nbsp;</p><p>Think back to that TypeError we got earlier from trying to call a string as a function. Most people don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.</p><p>&nbsp;</p><p>If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.</p><p>&nbsp;</p><p>Ideally, we could have a tool that helps us find these bugs before our code runs. That’s what a static type-checker like TypeScript does. Static type systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Non-exception Failures</strong></span></p><p>&nbsp;</p><p>So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected.</p><pre><code class="js javascript js-code">const user = {
  name: "Daniel",
  age: 26,
};
user.location; // returns undefined</code></pre><p>&nbsp;</p><p>For example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined.</p><pre><code class="js javascript js-code">const user = {
  name: "Daniel",
  age: 26,
};
 
user.location;
// Property 'location' does not exist on type '{ name: string; age: number; }'.</code></pre><p>&nbsp;</p><p>While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Types for Tooling</strong></span></p><p>&nbsp;</p><p>TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can also prevent us from making those mistakes in the first place.</p><p>&nbsp;</p><p>The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use.</p><p>&nbsp;</p><p>That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.</p><p>&nbsp;</p><p>TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that your favorite editor has TypeScript support available.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>tsc, the TypeScript compiler</strong></span></p><p>&nbsp;</p><p>We’ve been talking about type-checking, but we haven’t yet used our type-checker. Let’s get acquainted with our new friend tsc, the TypeScript compiler. First we’ll need to grab it via npm.</p><pre><code>npm install -g typescript</code></pre><p>&nbsp;</p><p>Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command tsc which was installed for us by the typescript package.</p><pre><code>tsc hello.ts</code></pre><p>&nbsp;</p><p>Wait, “tada” what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.</p><p>&nbsp;</p><p>But check again - we got some file output instead. If we look in our current directory, we’ll see a hello.js file next to hello.ts. That’s the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a .ts file:</p><pre><code class="js javascript js-code">// Greets the world.
console.log("Hello world!");</code></pre><p>&nbsp;</p><p>In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.</p><p>&nbsp;</p><p>What about if we did introduce a type-checking error? Let’s rewrite hello.ts:</p><pre><code class="js javascript js-code">// This is an industrial-grade general-purpose greeter function:
function greet(person, date) {
  console.log(`Hello ${person}, today is ${date}!`);
}
 
greet("Brendan");</code></pre><p>&nbsp;</p><p>If we run tsc hello.ts again, notice that we get an error on the command line!</p><p>&nbsp;</p><p>TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Emitting with Errors</strong></span></p><p>&nbsp;</p><p>One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, you will know better than TypeScript.</p><p>&nbsp;</p><p>To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?</p><p>&nbsp;</p><p>So TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag:</p><pre><code>tsc --noEmitOnError hello.ts</code></pre><p>&nbsp;</p><p>You’ll notice that hello.js never gets updated.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Explicit Types</strong></span></p><p>&nbsp;</p><p>Up until now, we haven’t told TypeScript what person or date are. Let’s edit the code to tell TypeScript that person is a string, and that date should be a Date object. We’ll also use the toDateString() method on date.</p><pre><code class="js javascript js-code">function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}</code></pre><p>&nbsp;</p><p>What we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as ”greet takes a person of type string, and a date of type Date“.</p><p>&nbsp;</p><p>With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For example…</p><pre><code class="js javascript js-code">function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
 
greet("Maddison", Date());
//Argument of type 'string' is not assignable to parameter of type 'Date'.</code></pre><p>&nbsp;</p><p>Huh? TypeScript reported an error on our second argument, but why?</p><p>&nbsp;</p><p>Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting.</p><p>&nbsp;</p><p>Anyway, we can quickly fix up the error:</p><pre><code class="js javascript js-code">function greet(person: string, date: Date) {
  console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
 
greet("Maddison", new Date());</code></pre><p>&nbsp;</p><p>Keep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just infer (or “figure out”) the types for us even if we omit them.</p><pre><code class="js javascript js-code">let msg = "hello there!";</code></pre><p>&nbsp;</p><p>Even though we didn’t tell TypeScript that msg had the type string it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.</p><p>&nbsp;</p><p>More on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.</p>