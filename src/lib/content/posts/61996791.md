---
id: '61996791'
title: 'Type Inference'
categories: 'TypeScript'
thumb: ''
date: '2025-09-15T15:44:12'
bookTitle: 'TypeScript for ES6 Developer'
bookThumb: ''
bookChapter: 'Basic Types'
videos: ''
---
<p>From Microsoft team</p><p>&nbsp;</p><p><strong>Summary</strong>: in this tutorial, you will learn about type inference in TypeScript.</p><p>&nbsp;</p><p>Type inference describes where and how TypeScript infers types when you don’t explicitly annotate them.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Basic type inference</strong></span></p><p>&nbsp;</p><p>When you declare a variable, you can use a type annotation to explicitly specify a type for it. For example:</p><pre><code class="js javascript js-code">let counter: number;</code></pre><p>&nbsp;</p><p>However, if you initialize the counter variable with a number, TypeScript will infer the type of the counter to be number. For example:</p><pre><code class="js javascript js-code">let counter = 0;</code></pre><p>&nbsp;</p><p>It is equivalent to the following statement:</p><pre><code class="js javascript js-code">let counter: number = 0;</code></pre><p>&nbsp;</p><p>Likewise, when you assign a function parameter a value, TypeScript infers the type of the parameter to the type of the default value. For example:</p><pre><code class="js javascript js-code">function setCounter(max=100) {
    // ...
}</code></pre><p>&nbsp;</p><p>In this example, TypeScript infers the type of the max parameter to be number.</p><p>&nbsp;</p><p>Similarly, TypeScript infers the following return type of the increment() function as number:</p><pre><code class="js javascript js-code">function increment(counter: number) {
    return counter++;
}</code></pre><p>&nbsp;</p><p>It is the same as:</p><pre><code class="js javascript js-code">function increment(counter: number) : number {
    return counter++;
}</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>The best common type algorithm</strong></span></p><p>&nbsp;</p><p>Consider the following assignment:</p><pre><code class="js javascript js-code">let items = [1, 2, 3, null];</code></pre><p>&nbsp;</p><p>To infer the type of items variable, TypeScript needs to consider the type of each element in the array.</p><p>&nbsp;</p><p>It uses the best common type algorithm to analyze each candidate type and select the type that is compatible with all other candidates.</p><p>&nbsp;</p><p>In this case, TypeScript selects the number or null array type (number | null) []) as the best common type. Note that the | means the OR operator in types.</p><p>&nbsp;</p><p>If you add a string to the items array, TypeScript will infer the type for the items as an array of numbers and strings: (number | string)[]</p><pre><code class="js javascript js-code">let items = [1, 2, 3, 'Cheese'];</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Contextual typing</strong></span></p><p>&nbsp;</p><p>TypeScript uses the locations of variables to infer their types. This mechanism is known as contextual typing. For example:</p><pre><code class="js javascript js-code">document.addEventListener('click', function (event) {
    console.log(event.button); 
});</code></pre><p>&nbsp;</p><p>In this example, TypeScript knows that the event parameter is an instance of MouseEvent because of the click event.</p><p>&nbsp;</p><p>However, when you change the click event to the scroll the event, TypeScript will issue an error:</p><pre><code class="js javascript js-code">document.addEventListener('scroll', function (event) {
    console.log(event.button); // compile error
});</code></pre><p>&nbsp;</p><p>Error:</p><pre><code>Property 'button' does not exist on type 'Event'.(2339)</code></pre><p>&nbsp;</p><p>TypeScript knows that the event in this case, is an instance of UIEvent, not a MouseEvent. And UIEvent does not have the button property, therefore, TypeScript throws an error.</p><p>&nbsp;</p><p>You will find contextual typing in many cases such as arguments to function calls, type assertions, members of objects and array literals, return statements, and right-hand sides of assignments.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Type inference vs. Type annotations</strong></span></p><p>&nbsp;</p><p>The following shows the difference between type inference and type annotations:</p><p>&nbsp;</p><figure class="table"><table><thead><tr><th>Type inference</th><th>Type annotations</th></tr></thead><tbody><tr><td>TypeScript guesses the type</td><td>You explicitly tell TypeScript the type</td></tr></tbody></table></figure><p>&nbsp;</p><p>So, when do you use type inference and type annotations?</p><p>&nbsp;</p><p>In practice, you should always use the type inference as much as possible. You use the type annotation in the following cases:</p><p>&nbsp;</p><ul><li>When you declare a variable and assign it a value later.</li><li>When you want a variable that can’t be inferred.</li><li>When a function returns the any type, you need to clarify the value.</li></ul><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Summary</strong></span></p><p>&nbsp;</p><ul><li>Type inference occurs when you initialize variables, set parameter default values, and determine function return types.</li><li>TypeScript uses the best common type algorithm to select the best candidate types that are compatible with all variables.</li><li>TypeScript also uses contextual typing to infer types of variables based on the locations of the variables.</li></ul>