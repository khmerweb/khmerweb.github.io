---
id: '47491592'
title: 'Building your First App'
categories: 'Node.js, Sveltekit'
thumb: ''
date: '2025-09-05T11:49:51'
bookTitle: 'Desktop App with Electron'
bookThumb: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgOwdngVcZR4tnR4nLZvdMvpivd7PA2iZwbiQMafn2xDXnaFvG7Vqe2kbmCWqRrABidMbpRNsCjgtr9G6C-xhmYvVlJlWq2GOTPMKSTVQHKYyn6Ja8rXq6cq0qIhDOpZz6ozArNgnLOxn3Bykf2hct6tomXbNuVD7HPfRxLAw-uU1FcDytseg5B4phnAGE/s1600/Capture.PNG'
bookChapter: 'Tutorial'
videos: ''
---
<p>from Electron team</p><p>&nbsp;</p><p>Electron is a framework for building desktop applications using JavaScript, HTML, and CSS. By embedding Chromium and Node.js into its binary, Electron allows you to maintain one JavaScript codebase and create cross-platform apps that work on Windows, macOS, and Linux â€” no native development experience required.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Initializing your npm project</strong></span></p><p>&nbsp;</p><p>Electron apps are scaffolded using npm, with the package.json file as an entry point. Start by creating a folder and initializing an npm package within it with npm init.</p><pre><code>mkdir my-electron-app &amp;&amp; cd my-electron-app
npm init</code></pre><p>&nbsp;</p><p>This command will prompt you to configure some fields in your package.json. There are a few rules to follow for the purposes of this tutorial:</p><p>&nbsp;</p><ul><li>entry point should be main.js (you will be creating that file soon).</li><li>author, license, and description can be any value, but will be necessary for packaging later on.<br>&nbsp;</li></ul><p>Then, install Electron into your app's devDependencies, which is the list of external development-only package dependencies not required in production.</p><pre><code>npm install electron --save-dev</code></pre><p>&nbsp;</p><p>Your package.json file should look something like this after initializing your package and installing Electron. You should also now have a node_modules folder containing the Electron executable, as well as a package-lock.json lockfile that specifies the exact dependency versions to install.</p><pre><code class="js javascript js-code">{
  "name": "my-electron-app",
  "version": "1.0.0",
  "main": "main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [
    "electron"
  ],
  "author": "Sokhavuth",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "electron": "^38.0.0"
  }
}
</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Running an Electron app</strong></span></p><p>&nbsp;</p><p>The main script you defined in package.json is the entry point of any Electron application. This script controls the main process, which runs in a Node.js environment and is responsible for controlling your app's lifecycle, displaying native interfaces, performing privileged operations, and managing renderer processes (more on that later).</p><p>&nbsp;</p><p>Before creating your first Electron app, you will first use a trivial script to ensure your main process entry point is configured correctly. Create a main.js file in the root folder of your project with a single line of code:</p><pre><code class="js javascript js-code">console.log('Hello from Electron!')</code></pre><p>&nbsp;</p><p>Because Electron's main process is a Node.js runtime, you can execute arbitrary Node.js code with the electron command (you can even use it as a REPL). To execute this script, add electron . to the start command in the scripts field of your package.json. This command will tell the Electron executable to look for the main script in the current directory and run it in dev mode.</p><pre><code class="js javascript js-code">{
  "name": "my-electron-app",
  "version": "1.0.0",
  "description": "Hello World!",
  "main": "main.js",
  "scripts": {
    "start": "electron .",
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "Jane Doe",
  "license": "MIT",
  "devDependencies": {
    "electron": "23.1.3"
  }
}</code></pre><pre><code>npm run start</code></pre><p>&nbsp;</p><p>Your terminal should print out Hello from Electron !. Congratulations, you have executed your first line of code in Electron! Next, you will learn how to create user interfaces with HTML and load that into a native window.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Loading a web page into a BrowserWindow</strong></span></p><p>&nbsp;</p><p>In Electron, each window displays a web page that can be loaded either from a local HTML file or a remote web address. For this example, you will be loading in a local file. Start by creating a barebones web page in an index.html file in the root folder of your project:</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    /&gt;
    &lt;meta
      http-equiv="X-Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    /&gt;
    &lt;title&gt;Hello from Electron renderer!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello from Electron renderer!&lt;/h1&gt;
    &lt;p&gt;ðŸ‘‹&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>&nbsp;</p><p>Now that you have a web page, you can load it into an Electron BrowserWindow. Replace the contents of your main.js file with the following code. We will explain each highlighted block separately.</p><pre><code class="js javascript js-code">const { app, BrowserWindow } = require('electron')

const createWindow = () =&gt; {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}

app.whenReady().then(() =&gt; {
  createWindow()
})</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Importing modules</strong></span></p><pre><code class="js javascript js-code">const { app, BrowserWindow } = require('electron')</code></pre><p>&nbsp;</p><p>In the first line, we are importing two Electron modules with CommonJS module syntax:</p><p>&nbsp;</p><ul><li>app, which controls your application's event lifecycle.</li><li>BrowserWindow, which creates and manages app windows.</li></ul><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Writing a reusable function to instantiate windows</strong></span></p><p>&nbsp;</p><p>The createWindow() function loads your web page into a new BrowserWindow instance:</p><pre><code class="js javascript js-code">const createWindow = () =&gt; {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Calling your function when the app is ready</strong></span></p><pre><code class="js javascript js-code">app.whenReady().then(() =&gt; {
  createWindow()
})</code></pre><p>&nbsp;</p><p>Many of Electron's core modules are Node.js event emitters that adhere to Node's asynchronous event-driven architecture. The app module is one of these emitters.</p><p>&nbsp;</p><p>In Electron, BrowserWindows can only be created after the app module's ready event is fired. You can wait for this event by using the app.whenReady() API and calling createWindow() once its promise is fulfilled.</p><p>&nbsp;</p><p>At this point, running your Electron application's start command should successfully open a window that displays your web page!</p><p>&nbsp;</p><p>Each web page your app displays in a window will run in a separate process called a renderer process (or simply renderer for short). Renderer processes have access to the same JavaScript APIs and tooling you use for typical front-end web development, such as using webpack to bundle and minify your code or React to build your user interfaces.</p><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Quit the app when all windows are closed (Windows &amp; Linux)</strong></span></p><p>&nbsp;</p><p>On Windows and Linux, closing all windows will generally quit an application entirely. To implement this pattern in your Electron app, listen for the app module's window-all-closed event, and call app.quit() to exit your app if the user is not on macOS.</p><pre><code class="js javascript js-code">app.on('window-all-closed', () =&gt; {
  if (process.platform !== 'darwin') app.quit()
})</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Open a window if none are open (macOS)</strong></span></p><p>&nbsp;</p><p>In contrast, macOS apps generally continue running even without any windows open. Activating the app when no windows are available should open a new one.</p><p>&nbsp;</p><p>To implement this feature, listen for the app module's activate event, and call your existing createWindow() method if no BrowserWindows are open.</p><p>&nbsp;</p><p>Because windows cannot be created before the ready event, you should only listen for activate events after your app is initialized. Do this by only listening for activate events inside your existing whenReady() callback.</p><pre><code class="js javascript js-code">app.whenReady().then(() =&gt; {
  createWindow()

  app.on('activate', () =&gt; {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Final starter code</strong></span></p><pre><code class="js javascript js-code">const { app, BrowserWindow } = require('electron/main')

const createWindow = () =&gt; {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}

app.whenReady().then(() =&gt; {
  createWindow()

  app.on('activate', () =&gt; {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

app.on('window-all-closed', () =&gt; {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})</code></pre><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    /&gt;
    &lt;meta
      http-equiv="X-Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    /&gt;
    &lt;title&gt;Hello from Electron renderer!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello from Electron renderer!&lt;/h1&gt;
    &lt;p&gt;ðŸ‘‹&lt;/p&gt;
    &lt;p id="info"&gt;&lt;/p&gt;
  &lt;/body&gt;
  &lt;script src="./renderer.js"&gt;&lt;/script&gt;
&lt;/html&gt;</code></pre><p>&nbsp;</p><p><span style="font-size:21px;"><strong>Summary</strong></span></p><p>&nbsp;</p><p>Electron applications are set up using npm packages. The Electron executable should be installed in your project's devDependencies and can be run in development mode using a script in your package.json file.</p><p>&nbsp;</p><p>The executable runs the JavaScript entry point found in the main property of your package.json. This file controls Electron's main process, which runs an instance of Node.js and is responsible for your app's lifecycle, displaying native interfaces, performing privileged operations, and managing renderer processes.</p><p>&nbsp;</p><p>Renderer processes (or renderers for short) are responsible for displaying graphical content. You can load a web page into a renderer by pointing it to either a web address or a local HTML file. Renderers behave very similarly to regular web pages and have access to the same web APIs.</p><p>&nbsp;</p><p>In the next section of the tutorial, we will be learning how to augment the renderer process with privileged APIs and how to communicate between processes.</p>